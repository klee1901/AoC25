import os
import math

def getIdLength(idInt):

    log10 = math.log(idInt,10)
    length = math.floor(log10) + 1

    return length

def getFactorsExcludingN(N):
    return [i for i in range(1,N) if N%i==0]

def getStart(idInt, idLength, startLength):
    # Get first startLength digits of idInt which has length idLength

    magnitudeOfRemainder = idLength - startLength
    
    return int(idInt // 10**magnitudeOfRemainder)

def generateInvalidId(generator, generatorLength, targetLength):
    # Repeat a sequence, generator, targetLength/generatorLength times

    invalidId = generator
    for repition in range(1,int(targetLength/generatorLength)):
        invalidId += generator* 10**(repition*generatorLength)
    
    return invalidId

def countInvalidIds(idLength, generatorLength, minId = None, maxId = None):
    # Determine how many generators of length generatorLength create invalid IDs of length idLength.
    # Invalid ids must be within bounds of minId and maxId (if supplied).

    if minId != None:
        iterStart = getStart(minId, idLength, generatorLength) + 1
    else:
        iterStart = 10**(generatorLength-1)

    if maxId != None:
        iterEnd = getStart(maxId, idLength, generatorLength)
    else:
        iterEnd = 10**generatorLength
    
    sumOfInvalidIds = []
    # Every invalid ID with generator greater than start of lower bound of range and lower than upper
    # bound of range is within range (don't need to compare to range endpoints)
    for generator in range(iterStart, iterEnd):
        sumOfInvalidIds += [generateInvalidId(generator, generatorLength, idLength)]
    # If both min and max IDs are provided and they have coincindent starts...
    if iterStart-1 == iterEnd and minId != None and maxId != None:
        # Check if the ID generated by the common start sequence is in range
        candidateInvalidId = generateInvalidId(iterStart-1, generatorLength, idLength)
        if candidateInvalidId >= minId and candidateInvalidId <= maxId:
            sumOfInvalidIds += [candidateInvalidId]
    else:
        # When either upper or lower range is bound, or bounds apply to seperate potential invalid IDs,
        # check these separately
        if minId != None:
            candidateInvalidId = generateInvalidId(iterStart-1, generatorLength, idLength)
            if candidateInvalidId >= minId:
                sumOfInvalidIds += [candidateInvalidId]
        if maxId != None:
            candidateInvalidId = generateInvalidId(iterEnd, generatorLength, idLength)
            if candidateInvalidId <= maxId:
                sumOfInvalidIds += [candidateInvalidId]

    return sumOfInvalidIds

class Range:

    def __init__(self,rangeAsStr):

        endpoints = rangeAsStr.split('-')

        self.__start = int(endpoints[0])
        self.__end = int(endpoints[1])

    def sumInvalidIds(self, generatorRepitions=2):

        lengthStartID = getIdLength(self.__start)
        lengthEndID = getIdLength(self.__end)

        invalidIds = []

        # When all IDs in range have common length we consider generators of a set length with extremes
        # compared to range end points
        if lengthStartID == lengthEndID:
            if lengthStartID % generatorRepitions == 0:
                invalidIds += countInvalidIds(
                    lengthStartID, int(lengthStartID/generatorRepitions), self.__start, self.__end
                )

        else:
            
            # If there are any IDs in range with a length not shared by one of the endpoints (none in
            # puzzle input), we sum all invalid IDs of that length
            for lengthID in range(lengthStartID+1,lengthEndID):
                if lengthID % generatorRepitions == 0:
                    invalidIds += countInvalidIds(lengthID, int(lengthID/generatorRepitions))
            
            # When the lower bound of the range is shorter than the upper bound we add all plausible
            # invalid ids of that length, comparing the lowest plausible to the lower bound of the range
            if lengthStartID % generatorRepitions == 0:
                invalidIds += countInvalidIds(
                    lengthStartID, int(lengthStartID/generatorRepitions), minId=self.__start
                )

            # When the upper bound of the range is longer than the lower bound we add all plausible
            # invalid ids of that length, comparing the highest plausible to the upper bound of the range
            if lengthEndID % generatorRepitions == 0:
                invalidIds += countInvalidIds(
                    lengthEndID, int(lengthEndID/generatorRepitions), maxId=self.__end
                )

        return sum(set(invalidIds))

    def sumAllInvalidIds(self):

        lengthStartID = getIdLength(self.__start)
        lengthEndID = getIdLength(self.__end)

        invalidIds = []

        # When all IDs in range have common length we consider generators of a set length with extremes
        # compared to range end points
        if lengthStartID == lengthEndID:
            for generatorLength in getFactorsExcludingN(lengthStartID):
                invalidIds += countInvalidIds(
                    lengthStartID, generatorLength, self.__start, self.__end
                )

        else:
            
            # If there are any IDs in range with a length not shared by one of the endpoints (none in
            # puzzle input), we sum all invalid IDs of that length
            for lengthID in range(lengthStartID+1,lengthEndID):
                for generatorLength in getFactorsExcludingN(lengthID):
                    invalidIds += countInvalidIds(lengthID, generatorLength)
            
            # When the lower bound of the range is shorter than the upper bound we add all plausible
            # invalid ids of that length, comparing the lowest plausible to the lower bound of the range
            for generatorLength in getFactorsExcludingN(lengthStartID):
                invalidIds += countInvalidIds(
                    lengthStartID, generatorLength, minId=self.__start
                )

            # When the upper bound of the range is longer than the lower bound we add all plausible
            # invalid ids of that length, comparing the highest plausible to the upper bound of the range
            for generatorLength in getFactorsExcludingN(lengthEndID):
                invalidIds += countInvalidIds(
                    lengthEndID, generatorLength, maxId=self.__end
                )

        return sum(set(invalidIds))

script_path = os.path.dirname(__file__)
rel_filepath = "../Input/day2.txt"
input_filepath = os.path.join(script_path, rel_filepath)

with open(input_filepath) as file:
    productRangesRaw = file.readline().split(',')
productRanges = [Range(rangeStr) for rangeStr in productRangesRaw]
invalidIdsSum = [productRange.sumInvalidIds() for productRange in productRanges]
allInvalidIdsSum = [productRange.sumAllInvalidIds() for productRange in productRanges]

print("Part 1: ", sum(invalidIdsSum))
print("Part 2: ", sum(allInvalidIdsSum))
